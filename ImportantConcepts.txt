


This document is a glossary of valuable information for this project




1. C++ Programming
Object-Oriented Programming (OOP): Understanding classes, inheritance, polymorphism, and encapsulation is essential for organizing game engine components like entities, renderers, shaders, and resources.
Memory Management: Since C++ doesnâ€™t have automatic garbage collection, mastering smart pointers (std::shared_ptr, std::unique_ptr), manual memory allocation (new and delete), and RAII is crucial for managing resources such as textures, shaders, and meshes.
Templates and STL: Knowledge of templates and the Standard Template Library (STL) (std::vector, std::map, etc.) helps in creating flexible, reusable code and managing collections of objects efficiently.
2. Linear Algebra and Geometry
Vectors and Matrices: Understanding how to work with 3D vectors, quaternions, and matrices (for transformations like translation, rotation, and scaling) is fundamental to 3D rendering.
Transformation Matrices: Mastering how to construct and apply model, view, and projection matrices to move objects, the camera, and to handle perspective and orthographic projections.
Cross Product, Dot Product, and Normals: These are key in calculating lighting, physics, and camera orientation.
3. OpenGL and Graphics Programming
Graphics Pipeline: Understanding the stages of the OpenGL rendering pipeline (vertex processing, rasterization, fragment processing, etc.) and how shaders (vertex, fragment) fit into it.
Shaders: Writing GLSL (OpenGL Shading Language) shaders to perform custom transformations, lighting, and post-processing effects is a core skill.
Textures and Buffers: Understanding how to load, bind, and manage textures, framebuffers, vertex buffer objects (VBOs), and vertex array objects (VAOs).
Depth Testing, Blending, and Face Culling: These techniques ensure efficient and accurate rendering of 3D scenes.
Framebuffers and Render Targets: Framebuffers allow off-screen rendering, useful for techniques like shadow mapping, reflections, or post-processing effects.
4. Real-Time Rendering Techniques
Lighting Models: Implementing basic lighting models such as Phong or Blinn-Phong, and more advanced models like physically-based rendering (PBR) for realistic material effects.
Shadow Mapping: Techniques for generating dynamic shadows from light sources.
Anti-Aliasing and Post-Processing: Handling post-processing effects such as anti-aliasing, bloom, tone mapping, and color grading.
Instancing and Batching: Techniques like instanced rendering to efficiently render large numbers of similar objects (e.g., grass, crowds) in one draw call.
5. Game Engine Design Patterns
Entity Component System (ECS): Understanding ECS architecture allows for efficient and flexible game object management by decoupling behavior (components) from data (entities).
Singletons and Factories: Frequently used for managing game subsystems (like rendering, input, resource loading) and creating objects dynamically.
Resource Management: Techniques for efficiently loading, caching, and unloading assets (textures, meshes, sounds) at runtime to optimize memory usage.
6. Mathematics for Physics and Animation
Collision Detection and Response: Implementing basic physics for object interactions, using bounding volumes (AABB, OBB) and algorithms like Separating Axis Theorem (SAT).
Interpolation: Using linear interpolation (LERP), spherical interpolation (SLERP), and keyframe animation for smooth transitions and animations.
Quaternions for Rotation: Using quaternions to avoid gimbal lock in smooth 3D rotations.
7. Multithreading and Optimization
Multithreading: As game engines often need to handle multiple tasks (physics, rendering, input) concurrently, understanding thread management, synchronization, and thread safety is important.
Data-Oriented Design: Minimizing cache misses by organizing data in a way that optimizes memory access patterns, a critical aspect for performance in games.
Profiling and Optimization: Techniques to measure and optimize CPU/GPU performance, including reducing draw calls, optimizing shaders, and minimizing state changes.
8. Input and Event Systems
Input Handling: Capturing and processing input from multiple sources (keyboard, mouse, gamepad) using event systems or polling, and translating them into camera movement, character control, etc.
Event Dispatching: Setting up an event system that propagates events like user inputs, window resizing, or collisions in a non-blocking way.
9. Resource Loading and Management
File I/O: Loading assets (textures, models, shaders) from disk. Familiarity with file formats (e.g., OBJ for models, PNG for textures) and loading them into memory.
Asset Pipeline: Managing assets during development, like converting them from source formats (e.g., 3D models, textures) into game-ready formats, and optimizing their runtime use.
10. Platform Abstraction
Cross-Platform Compatibility: Writing platform-independent code, abstracting OS-specific functionality (like window creation, input handling) so that your game engine works on multiple platforms (Windows, Linux, macOS).
External Libraries: Integrating third-party libraries such as GLFW (for window management), GLAD (for OpenGL loading), or libraries for physics (Bullet), sound (OpenAL), and file formats (Assimp for 3D models).